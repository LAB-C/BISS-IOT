/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/

var _ = require('underscore');
var utils = rootRequire('caver-utils');

var f = require('./formatters');

/**
 * Solidity의 type에 대해서 모두 import 받는다.
 * array, bool, int, uint, dynamicbytes, string, bytes
 */
var SolidityTypeAddress = require('./types/address');
var SolidityTypeBool = require('./types/bool');
var SolidityTypeInt = require('./types/int');
var SolidityTypeUInt = require('./types/uint');
var SolidityTypeDynamicBytes = require('./types/dynamicbytes');
var SolidityTypeString = require('./types/string');
var SolidityTypeBytes = require('./types/bytes');

/**
 * DynamicType인지 DynamicArray인지 판단.
 */
var isDynamic = function (solidityType, type) {
    return solidityType.isDynamicType(type) ||
        solidityType.isDynamicArray(type);
};


// result method
function Result() {}


/**
 * ABICoder prototype should be used to encode/decode solidity params of any type
 * var coder = new ABICoder([
       new SolidityTypeAddress(),
       new SolidityTypeBool(),
       new SolidityTypeInt(),
       new SolidityTypeUInt(),
       new SolidityTypeDynamicBytes(),
       new SolidityTypeBytes(),
       new SolidityTypeString()
   ]);
 * 이런 식으로 solidity type을 주욱 나열해준 types를 this._types에 달아준다.
 */
var ABICoder = function (types) {
    this._types = types;
};

/**
 * This method should be used to transform type to SolidityType
 *
 * @method _requireType
 * @param {String} type
 * @returns {SolidityType}
 * @throws {Error} throws if no matching type is found
 */

/**
 * 일반 type을 solidity type으로 바꿔주는 기능을 하는 메서드다.
 * ABICoder instance의 _types 즉, this._types에는 solidity type들이 주루룩 정의되어있는 배열이기 때문에,
 * 여기서 filter를 돌면서 존재하는 type인지 살핀 후에, 존재하지 않으면 에러를 뱉고,
 * 존재한다면 filter를 돌면서 찾은 solidityType을 리턴한다.
 */
ABICoder.prototype._requireType = function (type) {
    var solidityType = this._types.filter(function (t) {
        return t.isType(type);
    })[0];

    if (!solidityType) {
        throw Error('Invalid solidity type: ' + type);
    }

    return solidityType;
};



ABICoder.prototype._getOffsets = function (types, solidityTypes) {
    var lengths =  solidityTypes.map(function (solidityType, index) {
        return solidityType.staticPartLength(types[index]);
    });

    for (var i = 1; i < lengths.length; i++) {
        // sum with length of previous element
        lengths[i] += lengths[i - 1];
    }

    return lengths.map(function (length, index) {
        // remove the current length, so the length is sum of previous elements
        var staticPartLength = solidityTypes[index].staticPartLength(types[index]);
        return length - staticPartLength;
    });
};

/**
 * parameter로 날아온 types를 map으로 돌면서, solidityType화 해서 map으로 다시금 배열을 만들어준다.
 * self._requireType을 돌면서 ABICoder instance에 있는 this.types를 이용하는 듯이 보임.
 */
ABICoder.prototype._getSolidityTypes = function (types) {
    var self = this;
    return types.map(function (type) {
        return self._requireType(type);
    });
};


ABICoder.prototype._encodeMultiWithOffset = function (types, solidityTypes, encodeds, dynamicOffset) {
    var result = "";
    var self = this;

    types.forEach(function (type, i) {
        if (isDynamic(solidityTypes[i], types[i])) {
            result += f.formatInputInt(dynamicOffset).encode();
            var e = self._encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);
            dynamicOffset += e.length / 2;
        } else {
            // don't add length to dynamicOffset. it's already counted
            result += self._encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);
        }

        // TODO: figure out nested arrays
    });

    types.forEach(function (type, i) {
        if (isDynamic(solidityTypes[i], types[i])) {
            var e = self._encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);
            dynamicOffset += e.length / 2;
            result += e;
        }
    });
    return result;
};

// TODO: refactor whole encoding!
ABICoder.prototype._encodeWithOffset = function (type, solidityType, encoded, offset) {
    var self = this;
    if (solidityType.isDynamicArray(type)) {
        return (function () {
            // offset was already set
            var nestedName = solidityType.nestedName(type);
            var nestedStaticPartLength = solidityType.staticPartLength(nestedName);
            var result = encoded[0];

            (function () {
                var previousLength = 2; // in int
                if (solidityType.isDynamicArray(nestedName)) {
                    for (var i = 1; i < encoded.length; i++) {
                        previousLength += +(encoded[i - 1])[0] || 0;
                        result += f.formatInputInt(offset + i * nestedStaticPartLength + previousLength * 32).encode();
                    }
                }
            })();

            // first element is length, skip it
            (function () {
                for (var i = 0; i < encoded.length - 1; i++) {
                    var additionalOffset = result / 2;
                    result += self._encodeWithOffset(nestedName, solidityType, encoded[i + 1], offset +  additionalOffset);
                }
            })();

            return result;
        })();

    } else if (solidityType.isStaticArray(type)) {
        return (function () {
            var nestedName = solidityType.nestedName(type);
            var nestedStaticPartLength = solidityType.staticPartLength(nestedName);
            var result = "";


            if (solidityType.isDynamicArray(nestedName)) {
                (function () {
                    var previousLength = 0; // in int
                    for (var i = 0; i < encoded.length; i++) {
                        // calculate length of previous item
                        previousLength += +(encoded[i - 1] || [])[0] || 0;
                        result += f.formatInputInt(offset + i * nestedStaticPartLength + previousLength * 32).encode();
                    }
                })();
            }

            (function () {
                for (var i = 0; i < encoded.length; i++) {
                    var additionalOffset = result / 2;
                    result += self._encodeWithOffset(nestedName, solidityType, encoded[i], offset + additionalOffset);
                }
            })();

            return result;
        })();
    }

    return encoded;
};


/**
 * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.
 *
 * @method encodeFunctionSignature
 * @param {String|Object} functionName
 * @return {String} encoded function name
 */
/**
 * encodeFunctionSignature의 'functionName' 이라는 parameter로 올 수 있는 타입은 두 가지인데,
 * object형태로 왔다면, 이거는 jsonInterface를 준 것이기 때문에, utils 모듈의 _jsonInterfaceMethodToString
 * 메서드를 이용하고, string으로 왔다면, keccak256(혹은 sha3)을 이용해 4바이트까지 짜른다. 그런데 여기서 '0x'스트링을 포함해주기 때문에
 * '0x' + 4바이트 형식으로, 총 10글자까지 짜른다. (그래서 .slice(0, 10))
 */
ABICoder.prototype.encodeFunctionSignature = function (functionName) {
    if(_.isObject(functionName)) {
        functionName = utils._jsonInterfaceMethodToString(functionName);
    }

    return utils.sha3(functionName).slice(0, 10);
};


/**
 * Encodes the function name to its ABI representation, which are the first 4 bytes of the sha3 of the function name including  types.
 *
 * @method encodeEventSignature
 * @param {String|Object} functionName
 * @return {String} encoded function name
 */

/**
 * encodeEventSignature의 'functionName' 이라는 parameter로 올 수 있는 타입은 두 가지인데,
 * object형태로 왔다면, 이거는 jsonInterface를 준 것이기 때문에, utils 모듈의 _jsonInterfaceMethodToString
 * 메서드를 이용하고, string으로 왔다면, keccak256(혹은 sha3)을 이용해 4바이트까지 짜른다. 그런데 여기서 '0x'스트링을 포함해주기 때문에
 * '0x' + 4바이트 형식으로, 총 10글자까지 짜른다. (그래서 .slice(0, 10))
 * 사용 예)
 * i) string인 경우 cav.klay.abi.encodeEventSignature('myEvent(uint256,bytes32)')
 * ii) jsoninterface인 경우
 * cav.klay.abi.encodeEventSignature({
      name: 'myEvent',
      type: 'event',
      inputs: [{
          type: 'uint256',
          name: 'myNumber'
      },{
          type: 'bytes32',
          name: 'myBytes'
      }]
    })
 */
ABICoder.prototype.encodeEventSignature = function (functionName) {
    if(_.isObject(functionName)) {
        functionName = utils._jsonInterfaceMethodToString(functionName);
    }

    return utils.sha3(functionName);
};


/**
 * Should be used to encode plain param
 *
 * @method encodeParameter
 * @param {String} type
 * @param {Object} param
 * @return {String} encoded plain param
 *
 * Encodes a parameter based on its type to its ABI representation.
 * 실질적으로 일하는 애는 'encodeParameters'라고 기본적으로 array 형태로 들어오는 애들 처리해주는 애인데,
 * encodeParameter는 single parameter만 처리해주기 위해서, [type], [param]이런 식으로 붙여 줌.
 *
 * 결국 하는 일은, "type에 맞게 들어온 parameter를 encode" 해주는 기능을 한다.
 *
 * cav.klay.abi.encodeParameter('uint256', '2345675643');
 * > "0x000000000000000000000000000000000000000000000000000000008bd02b7b"
 * cav.klay.abi.encodeParameter('bytes32[]', ['0xdf3234', '0xfdfd']);
 * > "00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002df32340000000000000000000000000000000000000000000000000000000000fdfd000000000000000000000000000000000000000000000000000000000000"
 */
ABICoder.prototype.encodeParameter = function (type, param) {
    return this.encodeParameters([type], [param]);
};

/**
 * Should be used to encode list of params
 *
 * @method encodeParameters
 * @param {Array} types
 * @param {Array} params
 * @return {String} encoded list of params
 */

/**
 * 사용 예)
 * cav.klay.abi.encodeParameters(['uint256','string'], ['2345675643', 'Hello!%']);
 * > "0x000000000000000000000000000000000000000000000000000000008bd02b7b0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000748656c6c6f212500000000000000000000000000000000000000000000000000"
 * cav.klay.abi.encodeParameters(['uint8[]','bytes32'], [['34','434'], '0x324567fff']);
 * > "0x0000000000000000000000000000000000000000000000000000000000000040324567fff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000002200000000000000000000000000000000000000000000000000000000000001b2"
 */
ABICoder.prototype.encodeParameters = function (types, params) {
    // given a json interface
    // json interface 형식으로 types가 날아오면, 그에 맞게 처리를 해준다.
    if(_.isObject(types) && types.inputs) {
        types = _.map(types.inputs, function (input) {
            return input.type;
        });
    }

    var solidityTypes = this._getSolidityTypes(types);

    var encodeds = solidityTypes.map(function (solidityType, index) {
        return solidityType.encode(params[index], types[index]);
    });

    var dynamicOffset = solidityTypes.reduce(function (acc, solidityType, index) {
        var staticPartLength = solidityType.staticPartLength(types[index]);
        var roundedStaticPartLength = Math.floor((staticPartLength + 31) / 32) * 32;

        return acc + (isDynamic(solidityTypes[index], types[index]) ?
                32 :
                roundedStaticPartLength);
    }, 0);

    return '0x'+ this._encodeMultiWithOffset(types, solidityTypes, encodeds, dynamicOffset);
};


/**
 * Encodes a function call from its json interface and parameters.
 *
 * @method encodeFunctionCall
 * @param {Array} jsonInterface
 * @param {Array} params
 * @return {String} The encoded ABI for this function call
 */

/**
 * function call을 encode하는 메서드인데, 결국 function call을 encode한다는 것은,
 * encode된 function signature 와 encode된 parameter를 붙여준다는 것과 동일한 의미이다.
 * 즉, 이 메서드에서 하는 역할은 단순히 encode된 functionSignature 스트링과 encode된 parameter스트링에서
 * '0x'떼고 스트링 concatenate 하는게 끝이다.
 * 사용 예 )
 * cav.klay.abi.encodeFunctionCall({
    name: 'myMethod',
    type: 'function',
    inputs: [{
        type: 'uint256',
        name: 'myNumber'
    },{
        type: 'string',
        name: 'myString'
    }]
  }, ['2345675643', 'Hello!%']);
  > "0x24ee0097000000000000000000000000000000000000000000000000000000008bd02b7b0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000748656c6c6f212500000000000000000000000000000000000000000000000000"
 */
ABICoder.prototype.encodeFunctionCall = function (jsonInterface, params) {
    return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface, params).replace('0x','');
};


/**
 * Should be used to decode bytes to plain param
 *
 * @method decodeParameter
 * @param {String} type
 * @param {String} bytes
 * @return {Object} plain param
 */

/**
 * ABI bytecode를 decode할 때 쓰이는 메서드이다.
 * 사용 예 )
 * cav.klay.abi.decodeParameter('uint256', '0x0000000000000000000000000000000000000000000000000000000000000010');
 * > "16"
 * cav.klay.abi.decodeParameter('string', '0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000848656c6c6f212521000000000000000000000000000000000000000000000000');
 * > "Hello!%!"
 */
ABICoder.prototype.decodeParameter = function (type, bytes) {

    // parameter로 날아오는 type은 'string', 'uint256' 이렇게 스트링으로 싸여져있어야 한다.
    if (!_.isString(type)) {
        throw new Error('Given parameter type is not a string: '+ type);
    }

    return this.decodeParameters([{type: type}], bytes)[0];
};

/**
 * Should be used to decode list of params
 *
 * @method decodeParameter
 * @param {Array} outputs
 * @param {String} bytes
 * @return {Array} array of plain params
 */
ABICoder.prototype.decodeParameters = function (outputs, bytes) {
    var isTypeArray = _.isArray(outputs) && _.isString(outputs[0]);
    var types = (isTypeArray) ? outputs : [];

    if(!isTypeArray) {
        outputs.forEach(function (output) {
            types.push(output.type);
        });
    }

    var solidityTypes = this._getSolidityTypes(types);
    var offsets = this._getOffsets(types, solidityTypes);

    var returnValue = new Result();
    returnValue.__length__ = 0;
    var count = 0;

    outputs.forEach(function (output, i) {
        var decodedValue = solidityTypes[count].decode(bytes.replace(/^0x/i,''), offsets[count],  types[count], count);
        decodedValue = (decodedValue === '0x') ? null : decodedValue;

        returnValue[i] = decodedValue;

        if (_.isObject(output) && output.name) {
            returnValue[output.name] = decodedValue;
        }

        returnValue.__length__++;
        count++;
    });

    return returnValue;
};

/**
 * Decodes events non- and indexed parameters.
 *
 * @method decodeLog
 * @param {Object} inputs
 * @param {String} data
 * * @param {Array} topics
 * @return {Array} array of plain params
 */
ABICoder.prototype.decodeLog = function (inputs, data, topics) {

    data = data || '';

    var notIndexedInputs = [];
    var indexedInputs = [];

    inputs.forEach(function (input, i) {
        if (input.indexed) {
            indexedInputs[i] = input;
        } else {
            notIndexedInputs[i] = input;
        }
    });

    var nonIndexedData = data.slice(2);
    var indexedData = _.isArray(topics) ? topics.map(function (topic) { return topic.slice(2); }).join('') : topics;

    var notIndexedParams = this.decodeParameters(notIndexedInputs, nonIndexedData);
    var indexedParams = this.decodeParameters(indexedInputs, indexedData);


    var returnValue = new Result();
    returnValue.__length__ = 0;

    inputs.forEach(function (res, i) {
        returnValue[i] = (res.type === 'string') ? '' : null;

        if (notIndexedParams[i]) {
            returnValue[i] = notIndexedParams[i];
        }
        if (indexedParams[i]) {
            returnValue[i] = indexedParams[i];
        }

        if(res.name) {
            returnValue[res.name] = returnValue[i];
        }

        returnValue.__length__++;
    });

    return returnValue;
};

/**
 * import 된 solidity type들을 ABICoder instance의 this.types로 다 박아준다.
 */
var coder = new ABICoder([
    new SolidityTypeAddress(),
    new SolidityTypeBool(),
    new SolidityTypeInt(),
    new SolidityTypeUInt(),
    new SolidityTypeDynamicBytes(),
    new SolidityTypeBytes(),
    new SolidityTypeString()
]);

module.exports = coder;
